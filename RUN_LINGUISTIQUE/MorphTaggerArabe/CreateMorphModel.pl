#!/usr/bin/perl -w

use CorpusProbabilities;
use MorphTranslation;
use LM;
use strict;


my $outputlmname = $ARGV[0];	#corpus.morph.lm
my $outputmapname = $ARGV[1];
my $testparses = $ARGV[2];
my $langmodel  = $ARGV[3];	#corpus.lm
my $lexprobfile = $ARGV[4];
my $remove_corpus_analyses = $ARGV[5];
my $inc_svm = 0;

my $lowprob = 1e-10;	#(m,t) not in annotated corpus but in analyses

#given to morphemes which are taged with tags not seen neither in the corpus, 
#nor in the ambiguous corpus if present
my $verylowprob =1e-40;

my $EMPTYLINE = "emptyline [emptyline]";

#read the morpheme tag sequence language model generated by ngram-count over the 
#tags of the corpus, updates %LM in LM.pl.
ReadLM($langmodel);

print STDERR "Retrieving counted corpus...\n";
LoadLexicalProbabilitiesFromTextFile($lexprobfile);

print STDERR "no ambiguous corpus\n";

my @NGRAMS = ();
my @SENT_NGRAMS = ();
my $N=3;

############### converting test parses file  into an SRILM map-text file ##############

my $knownpairs = 0;
my $unknownpairs = 0;

my $outmap = $outputmapname . ".map";
my $reversemapping = $outputmapname. '.revmap';

print STDERR "Creating map file...\n";


my $BOS = 1;
open(TP,"<" . $testparses) or die "Can't open $testparses\n";

open(OM,">" . $outmap) or die "Can't open $outmap for output\n"; 
open(RM,">" . $reversemapping) or die "Can't open $reversemapping\n"; 

my %analyses = ();
my %parses = ();
my %parses_of_analyses = ();
my $word;

#4.6.08
#end of sentence changed to </sentence> to allow # in corpus.
#[TODO] for backward compatibality, the user should be allowed to chose
#between the two possibilities (# or </sentence>)

while (<TP>) {
  # end of sentence was reached, output end-of-sentence symbol
  #print STDERR $_;
  if (/<\/sentence>/ or /^\#\s*$/) {
    $knownpairs++ unless ($word and $word =~ /\?/); # for dots at end-of-sentence that were removed 
    #if we found empty line (consecutive </sentence>)
    if ( $BOS ) {
	PrintOM("<s> <s>\n$EMPTYLINE\n","<s> <s>\n$EMPTYLINE\n");
    }

    else{
        PrintMapLine();
    }
    
	PrintOM("</s> </s>\n","</s> </s>\n");
	
	AddNgramsToLM(keys %analyses);
    $word = "end-of-sentence";  # for debugging purpose only
    AddNgramsToLM("</s>");
    $BOS =1;
  } 
  #not implemented
  elsif (/<sentence num="\d+">/) {
  }
  #28.9.07
  #for DALIA
  elsif (/^\s*\<paragraph\/\>\S*$/) {
	  PrintOM("</p> </p>\n","");
  }
  else {	  
  
  chomp;
  s/^\s+//;
  s/\s+$//; 
  #s/ \S*?\d+\S*?\)/ NUM\)/g;
  unless (/\S+\s+\S+/) { # it's a word
    if ($BOS) {
      ClearNgrams();
      $word = "beginning-of-sentence";  # for debugging purpose only
      %analyses = ("<s>",1); 
      PrintOM("<s> <s>\n","<s> <s>\n");
	  $BOS = 0;
     }      
    else {
      PrintMapLine();
    }

    if (%analyses) {
      AddNgramsToLM(keys %analyses);
    }  
    $word = $_;
    PrintOM($word,"");
	
    # add all the analyses that exist in the corpus for this word
	#The analysis from the learning corpus are added here
    %parses = ();
    %analyses = ();
    %parses_of_analyses = ();
	#should be removed and done externally
	#print STDERR "CreateMorphModel.pl Ln127: remove_corpus_analyses=$remove_corpus_analyses\n";
	if ($remove_corpus_analyses eq "0"){
		foreach my $parse (keys %{$GPARSES{$word}}) {
			next if defined($parses{$parse});     
			$parses{$parse} = 1;
			my $analysis = ParseToTagSequence($parse);      
			$analysis =~ s/ /_/g;    
		      
			#caclculating P(word|analysis) = P(m1|t1)*P(m2|t2)*...*P(mn|tn)
			my $prob = MorphLexProb($parse);

			#in case of multiple parses per analysis, keep the most probable one
			if (defined($analyses{$analysis})) {

				if ($prob > $parses_of_analyses{$analysis}{"prob"}) {          
		#          print STDERR "CORPUS:replacing\n";
				$parses_of_analyses{$analysis}{"parse"}=$parse;
				$parses_of_analyses{$analysis}{"prob"}=$prob;
				}
			}
			# it's the first time the analysis was seen - save the parse and the probability
			else {
				$parses_of_analyses{$analysis}{"parse"}=$parse;
				$parses_of_analyses{$analysis}{"prob"}=$prob;        
				$analyses{$analysis} =1;
			}
		}
	}
  }
  else { # it's a parse
    my $parse = $_;

    next if defined ($parses{$parse});     
    $parses{$parse} = 1;
    my $analysis = ParseToTagSequence($parse);
    $analysis =~ s/ /_/g;    
 
    #caclculating P(word|analysis) = P(m1|t1)*P(m2|t2)*...*P(mn|tn)
    my $prob = MorphLexProb($parse);
	
    #in case of multiple parses per analysis, keep the most probable one
    if (defined($analyses{$analysis})) {
      if ($prob > $parses_of_analyses{$analysis}{"prob"}) {
#        print STDERR "replacing\n";
        $parses_of_analyses{$analysis}{"parse"}=$parse;
        $parses_of_analyses{$analysis}{"prob"}=$prob;
      }
    }
    # it's the first time the analysis was seen - save the parse and the probability
    else {
       $parses_of_analyses{$analysis}{"parse"}=$parse;
       $parses_of_analyses{$analysis}{"prob"}=$prob;        
       $analyses{$analysis} =1;
    }
  }
  
  } #end of else
}     

close(OM);
close(RM);

printf STDERR "known morph-tag pairs %d (%f6.2), unknown pairs %d (%f6.2)\n",
     $knownpairs,  100*$knownpairs  /($knownpairs+$unknownpairs),
     $unknownpairs,100*$unknownpairs/($knownpairs+$unknownpairs);

# output language model
OutputLM($langmodel);

################################# end of main program ##################################3

sub OutputLM {
  #open output lm corpus.morph.lm
  open(CMLM,">" . $outputlmname) 
    or die "Can't open $outputlmname for output\n"; 
  
  #print header
  print CMLM "\n\\data\\\n"; 
  my $n = $#NGRAMS;
  for (my $i=0;$i<=$n;$i++) {
      printf CMLM "ngram %d=%d\n",$i+1,scalar(keys %{$NGRAMS[$i]});
  }

  print CMLM "\n";

  for (my $i=0;$i<=$n;$i++) {
      printf CMLM "\\%d-grams:\n",$i+1;
      my $ngram;  
      foreach $ngram (sort keys %{$NGRAMS[$i]}) {
	if ($i<$n) {
          printf CMLM "%-10.6f $ngram -99\n",$NGRAMS[$i]{$ngram},$ngram;
        }
        else {
          printf CMLM "%-10.6f $ngram\n",$NGRAMS[$i]{$ngram},$ngram;
        } 
      }
      print CMLM "\n";
       
  }
  print CMLM "\\end\\\n"; 
  
}

sub ToMorphSeq {
  my $ngram = shift;
  $ngram =~ s/_\]//g;
  $ngram =~ s/\[_//g;
  $ngram =~ s/_/ /g;
  return $ngram;
}

#SequenceProb is imported from LM.pm, calculates prob from lm
sub GetNgramProb {
  my $ngram = shift;
  my $morph_ngram;
  $ngram =~ s/\s*(\S+)$//;
  $morph_ngram = $1;
  $ngram = ToMorphSeq($ngram);
  $morph_ngram = ToMorphSeq($morph_ngram);
#  print STDERR "{$ngram} {$morph_ngram}\n";
  return SequenceProb($morph_ngram,$N,$ngram);
}

#$NGRAMS is local  
sub AddNgram {
  my ($ngram,$order) = @_;
  my $prob; 
  unless (defined($NGRAMS[$order]{$ngram})) {
    $prob = GetNgramProb($ngram); 
    $prob = -99 if $prob <= -99;
    $NGRAMS[$order]{$ngram} = $prob;

    # add the prefix of the n-gram as well
    AddNgram(RemoveLast($ngram),$order-1) if $order;
  } 
}

sub ClearNgrams {
  @SENT_NGRAMS = ();
}

#$SENT_NGRAMS is local
sub AddNgramsToLM {
#  print STDERR "########################### $word ############################\n";
  @{$SENT_NGRAMS[scalar(@SENT_NGRAMS)]} = @_;
  foreach my $ngram (GetAllNgrams($#SENT_NGRAMS)) {
    AddNgram($ngram,$#SENT_NGRAMS);
  }
#  printf STDERR "--> %d\n",scalar(@SENT_NGRAMS); 
  if (scalar(@SENT_NGRAMS) == $N) {
    shift @SENT_NGRAMS;
  }
}


sub GetAllNgrams {
  my $n=shift;
#  print STDERR "n=$n\n";
  return @{$SENT_NGRAMS[0]} if ($n==0);

  my @outlist = ();
  foreach my $prefix (GetAllNgrams($n-1)) {
    foreach my $suffix (@{$SENT_NGRAMS[$n]}) {
      push @outlist, $prefix . " " . $suffix;
    }
  }
  return @outlist;
}

sub MorphLexProb {
  my $parse = shift;
  my $prob = 1;
  my $pairprob;

  my @mtpairs = ParseToMorphTagPairs($parse); 
  while (@mtpairs) {
    my $tag = shift @mtpairs;
    my $morph  = shift @mtpairs;

    $pairprob = MorphPairLexProb($tag,$morph);
#    return $pairprob if $pairprob <= $lowprob;
    $prob *= $pairprob;
  }        
  return $prob;
}


sub MorphPairLexProb {
  my ($tag,$morph) = @_;

  if (defined($GPAIRS{$tag}{$morph})) {
    $knownpairs++;
    return $GPAIRS{$tag}{$morph}/$GCATS{$tag} 
  }
  $unknownpairs++;
  return $lowprob;
}

sub PrintMapLine {
  foreach my $analysis (keys %analyses) {
	printf OM " %s %12e",$analysis,$parses_of_analyses{$analysis}{"prob"};
	printf RM " %s {%s}",$analysis,$parses_of_analyses{$analysis}{"parse"};
  }
  
  PrintOM("\n","\n");
}


#################################
sub PrintOM{
	my ($om,$rm) = @_;
	print OM $om;
	print RM $rm;
}

